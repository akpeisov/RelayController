+ hostname сделать с суффиксом мака Device_MAC
+ определение типа контроллера аппаратно для новых версий
+ default JWT in firmware
+ AP настройки как у WLED (точка может быть просто RC_AP)
- переделать hardware detection. Смотреть на список полученных устройств i2c и по нему понимать что есть, а чего нет
+ duration переделать на limit - ограничение по максимальному времени работы. Приоритет будет выше чем у экшенов.
- светодиод статус загрузки переделать
- OW ds18b20 сделать массив датчиков и опрос
- нужно что-то придумать с алисой и сценарием (событием кнопки/входа), чтобы полив запускать/отменять
- отправка данных в сокет по состоянию выполняющегося сценария с ожиданием



modbus

1. Сделать сохранение с фронта чтобы мастер знал типы слейвов
2. Проверить чтобы с бэка на мастер летел корректный конфиг со всеми входами и выходами
3. На контроллере скорректировать входы и выходы относительно типов слейвов
4. Проверить получение события со слейва и публикацию на бэк
5. Проверить правила относительно входа слейва на мастере (создание, сохранение и работу)
6. Отправку конфига модбас на контроллер (вместе с конфигом? + еще сеть и шедулер??? или смотреть версии каждого конфига отдельно?)
7. Когда с фронта прилетит конфиг в контроллер он же перетрет все выходы и входы слейвов и правила на них...
8. Если фронт у мастера отображает выходы и входы слейвов, то тогда как будут правила записываться и как отправляться в конфиг мастера? Может по-старому сделать, чтобы и с мастера все входы и выходы собирались и правила удобно будет делать...

- при получении входов и выходов со слейвов у них нет типов. надо брать их с самих слейвов?
А если они потом меняются, как синхронизировать?

modbus config
{
	"mode": "master",
	"pollingTime": 100,
	"readTimeout": 100,
	"maxRetries": 3,
	"actionOnSameSlave": false,
	"slaves": [
	{
                "slaveId": 2,
                "model": "RCV2B",
                "mac": "1234567890",
                "outputsState": 0,
                "inputsState":  0
        }
	]
}

{
	"mode": "slave",
	"slaveId": 1,
	"master": "123123123123"
}


На фронте
сделать выбор слейвов и мастера среди только своих устройств и чтобы не было пересечений если у юзера два и более мастеров, должны быть отдельные группы сетей
Еще должно быть меню шедулера

-------
новый конфиг

config - основной, внутри:
- io
- network
- scheduler
- modbus
- mqtt

---

Вместо трех кнопок (info, upload to controller и service) делаем одну иконку с шестеренкой и по нажатию на нее выпадающий список.
В списке:
- info. Открывается панель с информацией, как сейчас.
- reboot. Открывается диалоговое окно с подтверждением, если подтвердить вызывается метод reboot()
- update. Открывается диалоговое окно с подтверждением, если подтвердить вызывается метод startOTA()
- logs. Открывается панель с логами и кнопками enable send logs и disable send logs
- modbus. Открывается панель modbus. Описание ниже
- scheduler. Открывается панель scheduler. (Будет описано позже)
- network. Открывается панель настроек сети. (Будет описано позже)

Панель modbus
У dataservice.controllers добавился новый элемент - modbus. Пример для мастера
"modbus": {
    "mode": "master",
    "pollingTime": 200,
    "readTimeout": 200,
    "maxRetries": 3,
    "slaves": [
        {
            "uuid": "56f59932-6cb7-4918-bca1-ed69851f6e94",
            "slaveId": 2
        }
    ]
} и пример для слейва "modbus": {
            "mode": "slave",
            "slaveId": 2,
            "masterUUID": "b74cb0c0-e88a-4794-aab2-6984535df95b"
        }

На панели modbus
Выбор режима (modbus mode). Может быть None, Master, Slave
Если выбран режим Master, то ниже нужно выбрать один или несколько слейвов, отображая имена контроллеров из списка (dataservice.controllers), исключая текущий. Напротив каждого выбранного контроллера нужно отобразить поле ввода slaveid, который может быть в диапазоне 1..250, а так же не может быть двух слейвов с одним slaveid. 
При сохранении нужно отправить в вебсокет сообщение
{
	"type": "MODBUSSETCONFIG",
	"payload": {
    "mode": "master",
    "pollingTime": 200,
    "readTimeout": 200,
    "maxRetries": 3,
    "slaves": [
        {
            "uuid": "56f59932-6cb7-4918-bca1-ed69851f6e94",
            "slaveId": 2
        }
    ]
	}
}

Если выбран режим Slave, то просто отображает текущие настройки






Если выбран режим Slave, то 

{
	"mode": "slave",
	"slaveId": 2
}



Напиши метод, который принимает на входе (с фронта) данные вида
{
	"master": "master_uuid",
	"pollingTime": 100,
	"readTimeOut": 100,
	"maxRetries": 3,
	"slaves": [
		{
			"uuid": "slave_uuid",
			"slaveid": 1
		}
	]
}
и сохраняет это в ранее созданные структуры. Т.е. должна быть связка в rc_modbus и конфигурация в rc_modbus_config.
Так же метод должен удалить все другие ранее привязанные слейвы к этому мастеру, если таковые были.

А так же метод, который вернет данные в приведенной структуре, если на вход подается UUID мастера.
Наверное, надо сгенерировать DTO для этого...


